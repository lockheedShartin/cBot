/*
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdhyyhdhyyo+osmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmyddyhMMMNmdyo+/oNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmymNyohMMMMNNNms+++MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmNMNdmMMMMMNNNmh+:+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMsyNMMMNNMMMMMMMMNmd/`hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMshNNMMMMMMMMMMMMNNh::oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMydmmNNMMMMMMMMNMNh:`-+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMhdmNddNNNNNNNNNNy/```sMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMhsmmmhsoooooooooss:``sMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMd+hshmmdddddddmmdy-.:sMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMm+y+:dNNNNNMNNNmh+.:+ohmmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM+hs-smNNNMMNNNmh:-/shdmdhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdoy+:dmNMMMNNmmy-:+hmNNmy/-+hmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMhso/hmNMMMNNhds-:hmNms++shdmdhydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdoosdNNMMNmms:-ommy/sdNNNNmdds+smMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmys+hmNNNNNdy:+so+/hNNNNNNNNNmhsohMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMsso:sdNMNmmy++//s/-dNdhmmmNNNNmmdhsdMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmo/`oddmNmdds+.++/hmhsshddmNNNNmmmdyydNMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN:./symNNmyoo/oymNm+...:+sdmmNmmmmmds+hNMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN.:ohmNNmh+-.:hNNNmmdy+:.`./shdmddmmmd++hNMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMd.:+ddhyyo-  -dmNMNNNNNmhs/.`.:////oyhhyyyhmMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMy`:os++ss+`  omNNMMMMMMNNNmdyooooo/../hmmydhhmMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMs`-+oooso-  -ymNNMMMMMMMMNNNNNNNNmmhsso+oydddhhdNMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo`:/+ooo/` `odNNNMMMMMMMMNNNNNNNmNNNmds:.-/shhdhhhNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmh+.:///++-  /ymNNMMMMMMMMMNMMmNNNNNNNNNmmhs:.-+yddyyhmMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmhyydh:/o+/+/  -ohmNNMMMMMMMMMNNMmmNNNNNNNNNNNmmh+-.+yo+//sNMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMNNmmddmddmNNmy+o+++. `+ydNNNMMMMMMMMMMMNNmhdmmNNNNNNNNNNmdyhmmds-/oMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMNys/oyshmmmdmNNNmdoooo+` :shddmNNNMMMMMMNNNNmmmmhsydmmNNNNNNmmmmNmhho-:yMMMM
MMMMMMMMMMMMMMMNNmdyso+/:-:-/ydmmhyhmNmdhyso/sy:`/yddddmNNNNNNNNNNNNNmdhhsMNmdhhdmmddmNmNmmss+.:MMMM
MMMMMMMMMMMNmyo///+ooooooyhhhdmmo/oshdmmMN+o++ys/::oydmmmNmNNNNNNNNmmddhsdMMMMMMNmosdmNmNmdhys.:dMMM
MMMMMMMMNho//oyhhhys+/////++oydmh/mMMMMMMMs:yysysoso:/sdmNmNNNNNNNNmdmdysMMMMMMMMMhodmmdNddhhy-:hMMM
MMMMMMNs:/oyhysosyhdmdmdohyho-sddsNMMMMMMMm./+osho/shy+:/yhmmmmNNNNmhhyodMMMMMMMMMNohdmmNddhhy::hMMM
MMMMMd:/ydyo+ohmMMMMMMMNhddmh/sdhmMMMMMMMMM/oo++ymds/sddyo++-:+syhmmyssyMMMmddhdhyysoosyyhddds-:mMMM
MMMMM.ohdy:ohmMMMMMMNmNNNNmdyyhdNMMMMMMMMMM+shossydmdo/ydmhdyo:..-+shssmMmddmmdmmh:+yss+::+sho-/MMMM
MMMMM:ydh+-hmmmmmNmdmmNNmdhydmNMMMMMMMMMMMs++ymhdmdmmmho+hhddddhs/../+yMMNmmmmmdhy+hmshyoo:+o+-dMMMM
MMMMMdshhy++shdmmNmdddhyhdmMMMMMMMMMMMMMMh-++-hmmmmmmmmmdh++hhdddhy:`:hMMMMMMMMMMsdhyshdmh--oooMMMMM
MMMMMMMmmdhhhhhhhddddmNMMMMMMMMMMMMMMMMmho-//o+mNmNNmmmmmmdo:syyyhdh+.oMMMMMMMMMMMMMmoyddds-+sMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo+y:+:hdmNmNNNNmmNmmdy/:ss+sss++dMMMMMMMMMMMMMNoshmdhMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNso+shhdmmNNNNNNNNNmmmmdyoossssyyymMMMMMMMMMMMMMNsdNmddMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmdss/.ymNNNNNNNmmmmmmmmmmdhs+:/:::-/MMMMMMMMMMMMMMNhyymdNMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmyhyo-:hmNNNNNNNNNNNNNmmmmdhys./+:./+oMMMMMMMMMMMMMMMymmdmMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdsyo-:sdmNNNmNmNmmmNNNNNmmmdhdhyooo+/+oMMMMMMMMMMMMMMMmmNMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmss/-/ymmmmNNNmmmmmmmmNNmmNNNmmmdy:-yhhysNMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/


var experimental == false;

//unblocks console commands
if (!("console" in window) || !("firebug" in console)) { 
    console.log = null;
    console.log; // null

    delete console.log;

    var i = document.createElement('iframe');
    i.style.display = 'none';
    document.body.appendChild(i);
    window.console = i.contentWindow.console;
}

//override window.confirm event so that canvas doesn't stop the bot every time it tries to submit without filing out every question(block confirmation dialogs)
window.confirm = function() {
    return true;
};


//enhance privacy by blocking their js spyware
//allows "tabbing-out" and minimizing the window with/o site knowing for ex.
window.addEventListener("visibilitychange", function(event) { 
    event.stopPropagation();
    console.log("invasive js blocked: " + event);
}, true);


window.addEventListener("mousemove", function(event) {
    event.stopPropagation();
    console.log("invasive js blocked: " + event);
}, true);

window.addEventListener("blur", function(event) {
    event.stopPropagation();
    console.log("invasive js blocked: " + event);
}, true);

window.addEventListener("focus", function(event) {
    event.stopPropagation();
    console.log("invasive js blocked: " + event);
}, true);
console.log("finished enhancing privacy");










console.log("---PULLING FROM SS---");
//break their click speed checking function?

/*
_earlyClick = function() {
    console.log(e);
}
*/




//determine whether script is on an actual quiz page(where you can see the question), or if it is on the quiz summary page
if (document.querySelector("header.quiz-header h1").id == "") {


    if (sessionStorage.correctAnswers) {
        try {
            correctAnswers = JSON.parse(sessionStorage.correctAnswers);
            console.log("correct answers exist");
        } catch (e) {
            console.log("Caught: " + e.message + "(there are probably no correct answers yet)");
        }
    }


    try {
        badAnswers = JSON.parse(sessionStorage.badAnswers);
        console.log("badanswers exist");
    } catch (e) {
        console.log("Caught: " + e.message + "(there are probably no bad answers yet)");
    }

    try { //initialize questions array as being empty because questions should not be added unless they have been solved
        var questions = JSON.parse(sessionStorage.questions);
    } catch (e) {
        var questions = [];
    }

    try {
        var known = parseFloat(sessionStorage.known);
      console.log("succesfully pulled \"known\" incrementer from SS");
    } catch (e) {
        console.log("known blank");
    }
  
  try {
        var seen = JSON.parse(sessionStorage.seen);
      console.log("succesfully pulled list of seen questions from SS");
    } catch (e) {
        console.log("no questions have been seen yet, creating array");
      	var seen = [];
    }






		//store value containing how many questions are on the quiz (should be 10)
  	var numQuestions = document.querySelectorAll("#question_list li").length;
    //store what question is being asked
    var question = document.querySelector("div.question_text p").innerText;
  
  	console.log("---LOG QUESTION---");
  	//add question to list of seen questions
  var seenBool = false;
if(seen.length > 0)
  {
  	for(var l = 0; l < seen.length; l++)
      {
        if(seen[l]==question) {
          seenBool = true;
          console.log("we've already seen this question")
        }
        
      }
    
    	if(!seenBool){
        seen.push(question);
      }
    
  
  	
    }
  
   //push seen questions back onto SS
      sessionStorage.seen = JSON.stringify(seen);
  
  if(seen.length > numQuestions)
        {
          console.log("!!!There are more questions in the pool than there are questions themselves!!!");
          console.log("No. of Questions that could not be on this instance: "+(seen.length - numQuestions));
        }
  
  
  
      
     
     
  	

    //pulls list of answer row DOM objects
    var optionNodes = document.querySelectorAll("div.answer label.answer_row");
    //convert to array
    var optionNodeArray = Array.from(optionNodes);






    //
    //eliminate options
    //
    console.log("---ELIMINATING OPTIONS---");

    if (badAnswers) {
        for (var z = 0; z < optionNodeArray.length; z++) {
            for (var y = 0; y < badAnswers.length; y++) {
                if (optionNodeArray.length != 0) {
                    if (badAnswers[y] == optionNodeArray[z].getElementsByClassName("answer_label")[0].innerText || optionNodeArray[z].getElementsByClassName("answer_label")[0].innerText == "") { //check to make sure there is an option left by doing >= 2 //the second condition is there to remove blank options because whoever is making the quizzes apparently got lazy or something
                        console.log("Option: " + badAnswers[y] + " ELIMINATED");
                        console.log("optionNodeArray length: " + optionNodeArray.length);

                        //do wizardry to subtract from a node-list because node-lists don't behave like arrays because they are "live". So you have to convert them to an array.
                        optionNodeArray.splice(z, 1);

                        console.log("optionNodeArray length: " + optionNodeArray.length);

                        //make z index go back to 0 since it has been shortened
                        z = 0;
                        console.log("z index: " + z);




                    }
                } else {
                    console.log("I think all of the wrong answers were eliminated but the correct answer is also an incorrect answer from another problem. Skipping to the next question"); // this could probably be fixed with matrix's
                    if (known >= 0.1) {
                        known -= 0.1;
                    }

                    //ignore issue and go to next question
                    console.log("clicking next button");
                    document.querySelector("Button.submit_button.next-question").click();
                    throw '';





                }
            }
        }
    }



    //
    //DECIDE WHICH OPTION TO PICK
    //
    console.log("---DECIDING WHICH OPTION TO PICK---");




    //Checks if questions has already been solved
    if (correctAnswers) {
        for (var q = 0; q < (questions.length); q++) {
            if (question == questions[q]) {
                console.log("Question found in db");
                console.log(optionNodeArray.length + " options to compare to " + correctAnswers.length + " correctAnswers");
                for (var p = 0; p < optionNodeArray.length; p++) { //loop through options first because the options are the limiting factor. Ie. there could be more answers than options.
                    for (var b = 0; b < correctAnswers.length; b++) {
                        if (correctAnswers[b] == optionNodeArray[p].getElementsByClassName("answer_label")[0].innerText) {

                            //log match
                            console.log("MATCH:\ncorrectanswers[" + b + "]: " + correctAnswers[b] + "\noptionNodeArray[" + p + "]: " + optionNodeArray[p].getElementsByClassName("answer_label")[0].innerText);
                            console.log("Option chosen: optionNodeArray[" + p + "] (option " + (p + 1) + ")\n \"" + optionNodeArray[p].getElementsByClassName("answer_label")[0].innerText + "\"");


                            //checks radio button NOTE: this will be overwritten if program doesn't go to the next page because of line 124
                            console.log("Using answer found in local database");

                            //for every object in optionNodes, check and see if it's text is equal to that of its array counterparts text at index p
                            //if it is then mark it as the choice
                            //this may seem redundant but it is necessary because when the answer elimination block executes above, it is only changing the size of the optionNodeArray arra-
                            //-y not the optionNodes nodelist size as well. Because of that desynchronization, we must find the true index that should be used because of the offset caused-
                            //-by the splicing of the optionNodeArray array.
                            //Make doubly sure you want to remove it if you come to that point

                            for (var i = 0; i < optionNodes.length; i++) {
                                if (optionNodeArray[p].getElementsByClassName("answer_label")[0].innerText == optionNodes[i].getElementsByClassName("answer_label")[0].innerText) {
                                    //this holds the actual answer object.
                                    var choice = optionNodes[i];
                                    choice.querySelector("span.answer_input input").checked = true;
                                    console.log("option DOM object:");
                                    console.log(choice);
                                }
                            }


                            //increments amount of questions that we know for this session so that we can tell whether or not we get the next question that we don't know right
                            //if this is the first known then just initialize at 0
                          	
                          	console.log("known b4 incrementing: "+known);
                            console.log("incrementing known");
                            known += 0.1;
                        
                          	console.log("known after incrementing: "+known);
                            sessionStorage.known = null;
                          	known.toFixed(2);
                          console.log(sessionStorage.known);
                          	sessionStorage.known = known;


                            //press next button
                            console.log("clicking next button");
                            if (document.querySelector("Button.submit_button.next-question") != null) {
                                document.querySelector("Button.submit_button.next-question").click();
                                throw 'preventing race condition, i am';
                            } else {
                                console.log("is it the last question? No next button was found.");
                              if(known >= 0.8)
                                {
                                document.querySelector("div.form-actions #submit_quiz_button").click();
                                }
                              else
                                {
                                  alert("something went wrong. There seems to be questions we didn't have the answer to, despite what the DB says...");
                                }

                            }


                        } else {
                            /* console.log("initializing known");
                            var known = 0;
                            sessionStorage.known = known;
                            //console.log("known: " + known);
                            */
                        }






                    }



                }
            }




        }


    }


	//DECIDE WHAT TO PICK IF RANDOMLY GUESSING
	
    //decide which option to guessObject
    //generate random number from 0-(amount of options) for picking the option at random
  
  var optionIndex = Math.floor(Math.random() * (optionNodeArray.length));
  
  //all this logic does is match up the optionNodeArray index to the nodelist's index for the same object
  for (var i = 0; i < optionNodes.length; i++) {
                                if (optionNodeArray[optionIndex].getElementsByClassName("answer_label")[0].innerText == optionNodes[i].getElementsByClassName("answer_label")[0].innerText) {
                                  var guessNode = optionNodes[i]; 
                                  console.log("Index synchronized");
                                }
  }

    //checks radio button for the object held in the guessObject var
    guessNode.querySelector("span.answer_input input").checked = true;

    //store guess and question for this run through
    var guess = guessNode.querySelector("div.answer_label").innerText;
    sessionStorage.lastGuess = guess;
    sessionStorage.lastQuestion = question;



    //
    //
    // MOVE THINGS TO AND FROM SS
    //
    //


    //convert question array onto SS if there are questions
    if (!!questions) {
        sessionStorage.questions = JSON.stringify(questions);
    }
  	
  	

    sessionStorage.known = known;

    //checks if we have enough answers and click next if that is the case 
  	if(!!sessionStorage.questions && !!sessionStorage.correctAnswers)
      {
    if (JSON.parse(sessionStorage.questions).length >= 8 && JSON.parse(sessionStorage.correctAnswers).length >= 8 && experimental==true) //skip to next question if bot knows we have enough answers to get 0.8 (so 8 answers)
    {
        console.log("skipping this question because we have enough answers");
        if (document.querySelector("Button.submit_button.next-question")) { //this is here so that when the bot is on the last question then it can actually hit submit instead of the next button
            sessionStorage.known = known;
            document.querySelector("Button.submit_button.next-question").click();
            throw 'preventing race I am. allowing bot to go to next question i am';

        } else if (!document.querySelector("Button.submit_button.next-question")) {
            sessionStorage.known = known;
            console.log("hitting submit the last time before being done with this quiz!");
            document.querySelector("div.form-actions #submit_quiz_button").click();

            throw 'preventing race I am. allowing bot to go to next question i am';
        }


    }
      }


    //submits quiz
    console.log("we're about to click submit");
    document.querySelector("div.form-actions #submit_quiz_button").click();

    //kill script so it actually has time to hit submit
    throw 'Hi, i keep the script from raping itself by going too fast.';

} else if (!document.querySelector("header.quiz-header h1").id == "") { /*------------------------------------------------------------------------------------*/

    //delete attempt history table since it takes eons to load and slows down the program
    try {
        document.querySelector("#quiz-submission-version-table").remove();
    } catch (e) {
        console.log("no attempt table found");
    }

    //define retake button
    var retakeButton = document.querySelector("a.btn#take_quiz_link");


    //load arrays from SS
    //if array exists then convert it back from JSON if not then make array
    try {
        badAnswers = JSON.parse(sessionStorage.badAnswers);
    } catch (e) {
        console.log("there probably aren't any bad answers yet");
    }


    try {
        //cast to float
        var known = parseFloat(sessionStorage.known);
        console.log("known has been pulled from SS and equals " + known);
        // check if "known" incrementer exists if not then set to zero so that the calculations below will work
        if (!known) {
            console.log("known incrementer is for some reason NaN so we will initialize it to zero");
            var known = 0;
            //sessionStorage.known = known; we shouldn't have to touch known in this phase
        }
    } catch (e) {
        console.log("we probably never clicked next, earlier");
        var known = 0;
    }


    //pull whatever the last guess was from SS
    guess = sessionStorage.lastGuess;

    //find out score from attempt
    var score = document.querySelector("span.score_value").innerHTML;
    //sessionStorage.score = score;

    //if guessObject was correct then add it to sessionStorage in "correctAnswers
    if (score == (0.1 + known)) { //if score equals how many the bot knows it got correct + 0.1 then the last guess must have been correct

        if (sessionStorage.questions && sessionStorage.questions != "undefined") {
            questions = JSON.parse(sessionStorage.questions);
        } else //initialize questions array with first question
        {
            var questions = [question];
        }

        //add the last question to the list of solved questions
        questions.push(sessionStorage.lastQuestion);


        try {
            correctAnswers = JSON.parse(sessionStorage.correctAnswers);

            //error-checking to make sure answers are not being duplicated
            var isDuplicate = false;

            for (var u = 0; u < correctAnswers.length; u++) {
                if (correctAnswers[u] == guess) {
                    console.log("DUPLICATE, NOT ADDING TO ANSWER STACK")
                    isDuplicate = true;
                }
            }

            if (isDuplicate == false) {
                correctAnswers.push(guess);
                console.log("CORRECTANSWERS STACK NUDGED");
            }

        } catch (e) {
            var correctAnswers = [guess];
            console.log("initializing answers array");
            sessionStorage.correctAnswers = JSON.stringify(correctAnswers);
        }
        retakeButton.click();

    } else if (score >= 0.8) //if 0.8 is achieved then end job
    {
        console.log("passing score achieved, our job here is done. Get rekt.");
        window.alert("JOB COMPLETE");
        if (window.confirm("Would you like to export the key?")) {
            alert("answers: " + sessionStorage.correctAnswers + "\n" + "questions(solved): " + sessionStorage.questions);
        }

        if (window.confirm("Would you like to clear SS?\n\(you must clear SS if you want to use the script on a different quiz without restarting your browser!\)")) {
            sessionStorage.correctAnswers = [];
            sessionStorage.correctAnswers = [];
            sessionStorage.badAnswers = [];

            alert("SS CLEARED");
        }

    } else {

        //add guess to the list of bad answers
        if (!badAnswers) {
            var badAnswers = [guess];
            console.log("setting \"badAnswers\" array up fresh");
        } else {



            //error-checking to make sure answers are not being duplicated
            var isDuplicate = false;

            for (var s = 0; s < badAnswers.length; s++) {
                if (badAnswers[s] == guess) {
                    console.log("DUPLICATE, NOT ADDING TO BADANSWER STACK")
                    isDuplicate = true;
                }
            }

            if (isDuplicate == false) {
                badAnswers.push(guess);
                console.log("BADANSWERS STACK NUDGED");
            }
        }
        //hit retake since we confirmed that the guess was wrong
        retakeButton.click();

    }












    //reset known SS variable so that first half of bot script is not confused
    sessionStorage.known = 0;



    //
    //convert arrays back onto SS
    //


    if (badAnswers) {
        sessionStorage.badAnswers = JSON.stringify(badAnswers);
    }

    if (questions) {
        sessionStorage.questions = JSON.stringify(questions);
    }

    if (correctAnswers) {
        sessionStorage.correctAnswers = JSON.stringify(correctAnswers);
    }

}
